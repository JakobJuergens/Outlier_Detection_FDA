#' placeholder
#'
#' @param cl: cluster object generated by parallel package
#' @param list_path: path to the random access list of the data set (generated by package largeList)
#' this assumes that all observations are already zeroed and for every observation
#' there are more comparable counterparts than the parameter sample_size
#' @param lambda: allowed stretching parameter
#' @param n_samples: number of samples to use
#' @param sample_size: number of observations to use in each sample
#' @param alpha: quantile of least deep observations to drop before bootstrapping
#' (in approximation of C)
#' @param B: number of smoothed bootstrap samples to use (in approximation of C)
#' @param gamma: tuning parameter for smoothed bootstrap
#' @param debug: choose whether text outputs are given
#'
#' @return placeholder
#' @export
stretch_sample_detection <- function(cl, list_path, lambda, measuring_intervals,
                                     n_samples, sample_size,
                                     alpha, B, gamma, debug = FALSE) {
  # get number of observations in list
  n_obs <- getListLength(file = list_path)
  tmp_ids <- 1:n_obs

  # find unique measuring intervals
  unique_intervals <- unique_intervals(interval_matrix = measuring_intervals)
  n_unique_int <- dim(unique_intervals)[1]
  
  if (debug) {
    print(paste0("There are ", n_unique_int, " unique measuring intervals."))
  }

  # create vectors as described in the description part
  num_samples <- rep(x = 0, times = n_obs)
  num_outliers <- rep(x = 0, times = n_obs)
  frac_outliers <- rep(x = 1, times = n_obs)

  # iteration process
  for (i in 1:n_unique_int) {
    current_interval <- unique_intervals[i, ]

    # print out current measuring interval
    if (debug) {
      print(paste0("Current Interval: ", current_interval))
    }

    # find comparable observations
    comparable <- comparable_obs_finder(
      main_interval = unique_intervals[i, ],
      measuring_intervals = measuring_intervals,
      lambda = lambda, ids = tmp_ids
    )$ind

    # use stretching and sampling procedure for those comparable sets
    tmp_sample_res <- stretch_sample_wrap(
      cl = cl, list_path = list_path, main_interval = current_interval,
      indeces = comparable, n_samples = n_samples, sample_size = sample_size, 
      alpha = alpha, B = B, gamma = gamma
    )

    # update the vectors
    num_samples[comparable] <- num_samples[comparable] + tmp_sample_res$num_samples
    num_outliers[comparable] <- num_outliers[comparable] + tmp_sample_res$num_outliers
  }

  # calculate the relative frequency of outliers
  frac_outliers <- unlist(map(
    .x = 1:n_obs,
    .f = function(i) ifelse(num_samples[i] != 0, num_outliers[i] / num_samples[i], 1)
  ))

  # Return the three vectors
  return(list(
    num_samples = num_samples,
    num_outliers = num_outliers,
    certainties = frac_outliers
  ))
}
