#' placeholder
#'
#' @param cl: cluster object generated by parallel package
#' @param list_path: path to the random access list of the data set (generated by package largeList)
#' @param main_interval: measuring interval the observations are stretched to
#' @param indices: Vector containing the indeces of observations that are
#' included in the sampling procedure
#' @param n_samples: number of samples to use
#' @param sample_size: number of observations to use in each sample
#' @param alpha: quantile of least deep observations to drop before bootstrapping
#' (in approximation of C)
#' @param B: number of smoothed bootstrap samples to use (in approximation of C)
#' @param gamma: tuning parameter for smoothed bootstrap
#'
#' @return placeholder
#' @export
stretch_sample_wrap <- function(cl, list_path, main_interval,
                                indeces = NULL, n_samples, sample_size, alpha, B, gamma) {

  # get number of observations from the largeList file if indices is missing
  # Assumption: if no indices are given, all observations are being considered
  if (missing(indeces)) {
    indices <- 1:largeList::getListLength(list_path)
  }

  n_obs <- length(indeces)
  tmp_ids <- 1:n_obs

  # Initialize vectors described in the theoretical section
  num_samples <- rep(x = 0, times = n_obs)
  num_outliers <- rep(x = 0, times = n_obs)
  frac_outliers <- rep(x = 1, times = n_obs)

  # Draw indexes for sampling from functional data without replacement
  sample_inds <- map(
    .x = 1:n_samples,
    .f = function(i) sample(x = tmp_ids, size = sample_size, replace = FALSE)
  )

  # Determine how often each observation appeared in the samples and update the vector
  freq_samples <- tabulate(as.numeric(unlist(sample_inds)))
  num_samples[1:length(freq_samples)] <- num_samples[1:length(freq_samples)] + freq_samples

  # Perform the outlier classification procedure on the chosen samples parallelized
  # with the function clusterApplyLB() from the parallel package
  sample_flagged_par <- clusterApplyLB(
    cl = cl,
    x = sample_inds,
    fun = function(smpl) {
      stretch_sample_helper(
        list_path = list_path, main_interval = main_interval,
        ids = tmp_ids[smpl], index = indeces[smpl], alpha = alpha, B = B, gamma = gamma
      )
    }
  )

  # Determine how often each observation were flagged in the samples and update the vector
  # this check is a hack. Should be solved differently in the future
  if(length(sample_flagged_par) != 0){
    freq_outliers <- tabulate(as.numeric(unlist(sample_flagged_par)))
    num_outliers[1:length(freq_outliers)] <- num_outliers[1:length(freq_outliers)] + freq_outliers
  }
  
  # determine fraction of samples each observation was flagged as an outlier in
  certainties <- unlist(map(
    .x = 1:n_obs,
    .f = function(i) ifelse(num_samples[i] != 0, num_outliers[i] / num_samples[i], 1)
  ))

  # Return list containing the three central vectors: num_samples, num_outliers, certainties
  return(list(
    num_samples = num_samples,
    num_outliers = num_outliers,
    certainties = certainties
  ))
}

#' placeholder
#'
#' @param list_path: path to the random access list of the data set (generated by package largeList)
#' @param main_interval: Measuring interval currently under consideration
#' @param index: index of observations to use in the procedure 
#' (decided to be comparable in the calling function)
#' @param alpha: quantile of least deep observations to drop before bootstrapping (in approximation of C)
#' @param B: number of smoothed bootstrap samples to use (in approximation of C)
#' @param gamma: tuning parameter for smoothed bootstrap
#'
#' @return placeholder
stretch_sample_helper <- function(list_path, main_interval,
                                  ids, index, alpha, B, gamma) {

  # read in the observations identified by the variable index
  sample_dat <- readList(file = list_path, index = index)

  # stretch observations to the chosen measuring interval
  sample_dat_stretched <- stretch_data(
    func_dat = sample_dat, measuring_interval = main_interval
  )

  # perform the outlier detection procedure on the sample
  # in a tryCatch statement as the procedure creates notamatrix errors in random cases
  sample_flagged <- tryCatch(
    {
      detection_wrap(
        func_dat = sample_dat, ids = ids, 
        alpha = alpha, B = B, gamma = gamma)$outlier_ids
    },
    error = function(cond) {
      return(list(outlier_ids = c(), outlier_ind = c()))
    }
  )

  # return the object generated by the outlier detection procedure
  return(sample_flagged)
}
