#' Performs the sampling procedure on a data set.
#'
#' @param cl: cluster object generated by parallel package
#' @param list_path: path to the random access list of the data set (generated by package largeList)
#' assumes that the observations are already zeroed and share the same measuring
#' interval
#' @param indices: Vector containing the indeces of observations that are
#' included in the sampling procedure
#' @param n_samples: number of samples to use
#' @param sample_size: number of observations to use in each sample
#' @param alpha: quantile of least deep observations to drop before bootstrapping
#' (in approximation of C)
#' @param B: number of smoothed bootstrap samples to use (in approximation of C)
#' @param gamma: tuning parameter for smoothed bootstrap
#'
#' @return A list containing three elements:
#' num_samples: The number of samples each observation was part of (vector)
#' num_outliers: The number of samples each observation was classified as an outlier in (vector)
#' certainties: The quotient of num_outliers and num_samples (so the relative frequency of 
#' observations being classified as outliers)
#' @export
sample_wrap <- function(cl, list_path, indeces = NULL, n_samples, sample_size, alpha, B, gamma) {

  # get number of observations from the largeList file if indices is missing
  # Assumption: if no indices are given, all observations are being considered
  if (missing(indeces)) {
    indices <- 1:largeList::getListLength(list_path)
  }

  n_obs <- length(indeces)
  tmp_ids <- 1:n_obs

  # Initialize vectors described in the theoretical section
  num_samples <- rep(x = 0, times = n_obs)
  num_outliers <- rep(x = 0, times = n_obs)
  frac_outliers <- rep(x = 1, times = n_obs)

  # Draw indexes for sampling from functional data without replacement
  sample_inds <- map(
    .x = 1:n_samples,
    .f = function(i) sample(x = tmp_ids, size = sample_size, replace = FALSE)
  )

  # Determine how often each observation appeared in the samples and update the vector
  freq_samples <- tabulate(as.numeric(unlist(sample_inds)))
  num_samples[1:length(freq_samples)] <- num_samples[1:length(freq_samples)] + freq_samples

  # Perform the outlier classification procedure on the chosen samples parallelized
  # with the function clusterApplyLB() from the parallel package
  sample_flagged_par <- clusterApplyLB(
    cl = cl,
    x = sample_inds,
    fun = function(smpl) {
      sample_helper(
        list_path = list_path, ids = tmp_ids[smpl], index = indeces[smpl],
        alpha = alpha, B = B, gamma = gamma
      )
    }
  )

  # Determine how often each observation were flagged in the samples and update the vector
  freq_outliers <- tabulate(as.numeric(unlist(sample_flagged_par)))
  num_outliers[1:length(freq_outliers)] <- num_outliers[1:length(freq_outliers)] + freq_outliers

  # termine fraction of samples each observation was flagged as an outlier in
  certainties <- unlist(map(
    .x = 1:n_obs,
    .f = function(i) ifelse(num_samples[i] != 0, num_outliers[i] / num_samples[i], 1)
  ))

  # Return list containing the three central vectors: num_samples, num_outliers, certainties
  return(list(
    num_samples = num_samples,
    num_outliers = num_outliers,
    certainties = certainties
  ))
}

#' This function is a helper to sample_wrap() and performs the detection procedure for
#' a single sample.
#'
#' @param list_path: path to the random access list of the data set (generated by package largeList)
#' @param index: index of observations to use in the procedure
#' @param alpha: quantile of least deep observations to drop before bootstrapping (in approximation of C)
#' @param B: number of smoothed bootstrap samples to use (in approximation of C)
#' @param gamma: tuning parameter for smoothed bootstrap
#'
#' @return ids from the output of detection_wrap
sample_helper <- function(list_path, ids, index, alpha, B, gamma) {

  # read in the observations identified by the variable index
  sample_dat <- readList(file = list_path, index = index)

  # perform the outlier detection procedure on the sample
  # in a tryCatch statement as the procedure creates notamatrix errors in random cases
  sample_flagged <- tryCatch(
    {
      detection_wrap(func_dat = sample_dat, ids = ids, alpha = alpha, B = B, gamma = gamma)
    },
    error = function(cond) {
      return(list(outlier_ids = c(), outlier_ind = c()))
    }
  )

  # return the object generated by the outlier detection procedure
  return(sample_flagged$ids)
}
