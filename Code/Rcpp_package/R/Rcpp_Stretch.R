#' placeholder
#'
#' @param obs: a list that conatins two vectors of identical length: args and vals
#' @param measuring_interval: a vector with 2 elements,
#' the start and end points of the desired measuring interval
#'
#' @return placeholder
#' @export
stretch_obs <- function(obs, measuring_interval) {

  # calculate stretching factor
  phi <- (measuring_interval[2] - measuring_interval[1]) / (max(obs$args) - min(obs$args))

  # stretch arguments by appropriate factor
  args_stretched <- obs$args * phi

  # return in the format for functional observations
  return(list(
    args = args_stretched,
    vals = obs$vals
  ))
}

#' placeholder
#'
#' @param func_dat: list that contains the observations
#' each observation is a list, that conatins two vectors of identical length: args and vals
#' @param measuring_interval: a vector with 2 elements,
#' the start and end points of the desired measuring interval
#'
#' @return placeholder
#' @export
stretch_data <- function(func_dat, measuring_interval) {

  # apply function stretch_obs() to each observation in the data set
  stretch_dat <- map(
    .x = func_dat,
    .f = function(obs) stretch_obs(obs = obs, measuring_interval = measuring_interval)
  )

  # return list of stretched observations
  return(stretch_data)
}

#' placeholder
#'
#' @param list_path: path to the random access list of the data set
#' (generated by package largeList)
#' @param index: index of observations to use in the procedure
#' @param alpha: quantile of least deep observations to drop before bootstrapping
#' (in approximation of C)
#' @param B: number of smoothed bootstrap samples to use
#' (in approximation of C)
#' @param gamma: tuning parameter for smoothed bootstrap
#' @param measuring_interval: a vector with 2 elements, the start and end points
#' of the desired measuring interval
#'
#' @return placeholder
#' @export
random_access_par_stretch_helper <- function(list_path, ids, index, alpha, B, gamma, measuring_interval) {

  # read in the observations identified by the variable index
  func_dat <- stretch_data(
    func_dat = readList(file = list_path, index = index),
    measuring_interval = measuring_interval
  )

  # perform the outlier detection procedure on the sample
  # in a tryCatch statement as the procedure creates notamatrix errors in random cases
  sample_flagged <- tryCatch(
    {
      detection_wrap(func_dat = func_dat, ids = ids, alpha = alpha, B = B, gamma = gamma)
    },
    error = function(cond) {
      return(list(outlier_ids = c(), outlier_ind = c()))
    }
  )

  # return the object generated by the outlier detection procedure
  return(sample_flagged$outlier_ids)
}

#' placeholder
#'
#' @param cl: cluster object generated by parallel package
#' @param n_samples: number of samples to use
#' @param sample_size: number of observations to use in each sample
#' @param alpha: quantile of least deep observations to drop before bootstrapping
#' (in approximation of C)
#' @param B: number of smoothed bootstrap samples to use (in approximation of C)
#' @param gamma: tuning parameter for smoothed bootstrap (in approximation of C)
#' @param list_path: path to the random access list of the data set
#' (generated by package largeList)
#' @param measuring_interval: a vector with 2 elements,
#' the start and end points of the desired measuring interval
#' @param comparable: vector with the indices of comparable observations in the largelist
#'
#' @return placeholder
#' @export
stretch_and_sample <- function(cl, n_samples, sample_size, alpha, B, gamma, list_path, measuring_interval, comparable) {
  ids <- comparable

  # Initialize vectors described in the theoretical section
  num_samples <- rep(x = 0, times = length(comparable))
  num_outliers <- rep(x = 0, times = length(comparable))
  frac_outliers <- rep(x = 1, times = length(comparable))

  # Draw indexes for sampling from functional data without replacement
  sample_inds <- map(
    .x = 1:n_samples,
    .f = function(i) sample(x = ids, size = sample_size, replace = FALSE)
  )

  # Determine how often each observation appeared in the samples and update the vector
  freq_samples <- tabulate(unlist(sample_inds))
  num_samples[1:length(freq_samples)] <- num_samples[1:length(freq_samples)] + freq_samples

  # Perform the outlier classification procedure on the chosen samples parallelized
  # with the function clusterApplyLB() from the parallel package
  sample_flagged_par <- clusterApplyLB(
    cl = cl,
    x = sample_inds,
    fun = function(smpl) {
      random_access_par_stretch_helper(
        list_path = list_path, ids = ids[smpl],
        index = smpl, alpha = alpha, B = B, gamma = gamma,
        measuring_interval = measuring_interval
      )
    }
  )

  # Determine how often each observation were flagged in the samples and update the vector
  freq_outliers <- tabulate(unlist(sample_flagged_par))
  num_outliers[1:length(freq_outliers)] <- num_outliers[1:length(freq_outliers)] + freq_outliers

  # termine fraction of samples each observation was flagged as an outlier in
  certainties <- unlist(map(
    .x = 1:n_obs,
    .f = function(i) ifelse(num_samples[i] != 0, num_outliers[i] / num_samples[i], 1)
  ))

  # Return list containing the three central vectors: num_samples, num_outliers, certainties
  return(list(
    num_samples = num_samples,
    num_outliers = num_outliers,
    certainties = certainties
  ))
}

#' placeholder
#'
#' @param cl: cluster object generated by parallel package
#' @param list_path: path to the random access list of the data set (generated by package largeList)
#' @param measuring_intervals: matrix of measuring intervals
#' @param n_obs: number of observations in the data set
#' @param lambda: acceptable stretching parameter
#' @param n_samples: number of samples to use in each iteration
#' (NULL for procedure determining value)
#' @param sample_size: number of observations to use in each sample in each iteration
#' (NULL for procedure determining value)
#' @param alpha: quantile of least deep observations to drop before bootstrapping
#' (in approximation of C) (NULL for procedure determining value)
#' @param B: number of smoothed bootstrap samples to use (in approximation of C)
#' (NULL for procedure determining value)
#' @param gamma: tuning parameter for smoothed bootstrap (in approximation of C)
#'
#' @return placeholder
#' @export
dectection_zr_smpl <- function(cl, list_path, measuring_intervals, n_obs, lambda, 
                               n_samples = NULL, sample_size = NULL, alpha = NULL, 
                               B = NULL, gamma = 0.05) {

  # generate useful identifiers for vectors
  ids <- 1:n_obs

  # create vectors as described in the description part
  num_samples <- rep(x = 0, times = n_obs)
  num_outliers <- rep(x = 0, times = n_obs)
  frac_outliers <- rep(x = 1, times = n_obs)

  # determine unique intervals to iterate through
  unique_intervals <- unique_intervals(measuring_intervals)
  n_intervals <- dim(unique_intervals)[1]

  # iteration process
  for (i in 1:n_intervals) {

    # Possible output
    print(paste0(i, " out of ", n_intervals))

    # find comparable observations
    comparable <- comparable_obs_finder(
      main_interval = unique_intervals[i, ],
      measuring_intervals = measuring_intervals,
      lambda = lambda, ids = ids
    )
  
    # do stretching and sampling procedure on current comparable observations
    intv_res <- stretch_and_sample(
      cl = cl, n_samples = n_samples, sample_size = sample_size,
      alpha = alpha, B = B, gamma = gamma, list_path = list_path,
      measuring_interval = unique_intervals[i, ], comparable = comparable #statt unique intervals vorher measuring itnervals
    )

    # update the vectors
    num_samples[comparable] <- num_samples[comparable] + intv_res$num_samples
    num_outliers[comparable] <- num_outliers[comparable] + intv_res$num_outliers
  }

  # calculate the relative frequency of outliers
  frac_outliers <- unlist(map(
    .x = 1:n_obs,
    .f = function(i) ifelse(num_samples[i] != 0, num_outliers[i] / num_samples[i], 1)
  ))

  # Return the three vectors
  return(list(
    num_samples = num_samples,
    num_outliers = num_outliers,
    certainties = frac_outliers
  ))
}
